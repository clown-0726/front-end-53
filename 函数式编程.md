- 编程范式
- 函数式编程是范畴论的数学分支是一门很复杂的数学，认为世界上所有的概念体系都可以抽象出一个个范畴
- 彼此之间存在某种关系概念、事物、对象等等，都构成范畴。任何事物只要找出他们之间的关系，就能定义
- 箭头表示范畴成员之间的关系，正式的名称叫做“态射”。范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”。通过“态射”，一个成员可以变成另一个成员
- 函数式编程（Functional Programming）其实相对于计算机的历史而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基数模型源于 λ(lambda x=>x^2) 演算，而 λ 演算并非设计于在计算机上执行，它是在20世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统。
- 函数式编程不是用于函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符号合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用。
- 真正的火热是随着 React 的高阶函数而逐步升温。
- 区分“用函数编程”和“函数式编程”，借助数学的方式用js语法实现的编程。
- 函数是一等公民。所谓“第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
- 不可改变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了。在函数式编程中变量仅仅代表某个表达式。这里所说的“变量”是不能被修改的。所有的变量只能被赋值一次初值。
- map & reduce 他们是最常用的函数式编程的方法。
- 函数式“第一等公民” ｜ 只用“表达式”，不用“语句” ｜ 没有“副作用” ｜ 不修改状态 ｜ 引用透明（函数运行只靠参数）



### xxx

##### 纯函数

对于相同的输入，永远会得到相同的输出，而且没有任何可观察到副作用，也不依赖外部环境的状态。

纯函数不仅可以有效降低系统的复杂度，还有很多其他的特性，比如可缓存性。

```
var xs = [1,2,3,4,5]

```

##### 函数的柯里化

传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。事实上这是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。

```
var checkage = min => (age => age > min)
var checkage18 = checkage(18)
checkage18(20)
```

```
function foo(p1, p2) {
  this.val = p1 + p2;
}
var bar = foo.bind(null, 'p1')
var bar = new bar("p2");
console.log(baz.val);
```

```js
import _ from 'lodash';
var sin = _.memorize(x=> Math.sin(x));

// 第一次计算的时候会稍慢一点
var a = sin(7);

// 第二次有了缓存，速度极快
var b = sin(7);
// 存函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存行
```

```js
// 柯里化之前
function add(x, y){return x+y}
add(1,2)

// 柯里化之后
function addX(y){
 return function(x){
   return x+y;
 }
}
addX(2)(1)
```

存函数以及如何把它柯里化写出的洋葱代码h(g(f(x)))，为了解决函数的嵌套问题，我们需要用到“函数组合”

```
const compose = (f, g) => (x=>f(g(x)));
var first = arr => arr[0];
var reverse = arr = arr.reverse();
var last = compose(first, reverse);
last([1,2,3,4,5])
```



#### Point Free

把一些对象自带的方法转换成纯函数，不要命名转瞬即逝的中间变量。

这个函数中，我们使用了 str 作为我们的中间变量，但是这个中间变量处理让我们代码变长以外毫无意义。

`const f = str => str.toUpperCase().split(' ')`

```
var toUpperCase = word => word.toUpperCase();
var split = x => (str => str.split(x));

var f = compose(split(' '), toUpperCase);
f('abcd efgh')
```

这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用

#### 声明式和命令式代码

命令式代码就通过编写一条又一条指令让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。

```
// 命令式
let CEOs = []
for(var i = 0;i<companies.length;i++) {
  CEOs.push(companies[i].CEO)
}

// 声明式
let CEOs = companies.map(c=>c.CEO)
```



函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的存函数，我们完全可以不考虑函数内部式如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。

相反不纯的函数代码会产生副作用或者依赖外部系统环境，使用他们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。



惰性函数，惰性求知



#### 高阶函数

函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象

```
// 命令式
var add = function(a, b){
  return a + b;
}
function math(func, array){
  return func(array[0], array[1])
}
math(add, [1, 2])
```

#### 尾递归问题

尾递归的判断标准是函数运行（最后一步）是否调用自身，而不是是否在函数的（最后一行）调用自身，最后一行调用其他函数并返回叫尾调用。

按道理尾递归调用调用栈永远都是更新当前的栈帧而已，这样就完全避免了爆栈的危险。但是现如今的浏览器并未完全支持，原因有二：1 在引擎层面消除递归是一个隐式的行为，程序员意识不到。2堆栈信息丢失了开发者难以调试。

既然浏览器不支持我们就可以把这些递归写成while

